SCRIPTS CAN BE FOUND IN :   ~/Learning/Bash/scipts/

Bash is a shell program to effeciently interact with operating system of a computer.
Using GUI to interact is not the fastest way.
Bash can be used to automate tasks in computer.


LESSON: ALIASES
***************
Bash alias: A shortcut to frequently used possibly long commands.

To see all alias: $ alias
OUTPUT:-
alias grep='grep --color=auto'
alias l='ls -CF'
alias la='ls -A'
alias ll='ls -alF'
alias ls='ls --color=auto'

To execute the original 'ls' command, use '\'  LIKE:   $ \ls


Creating an alias: $ alias <alias_name> = '<command_in_single_quotes>'
ex:   $ alias c = 'clear'
(Note: The single quotes are only necessary when the command contains spaces)
(Note: The alias will only be available for the current session, i.e it'll be gone if you close the terminal)

To make an alias which will work at all times(even after restarting PC), edit the bashrc file
$ vim ~/.bashrc	   <- At the end of this file, append your alias command and save it (You can also use nano instead of vim)

I've added the following alias at the end of .bashrc
alias now='date +%F\ %T'	<= Display date&time

Now, if I open a new terminal, or restart the PC, the alias 'now' will still work

.bashrc is loaded when you start a terminal... So, if you created an alias after already starting the terminal, you can either restart the terminal or you can manually update the .bashrc with following command
$ source .bashrc

To remove an alias: $ unalias <alias_name>
ex:  $ unalias now
(Note: Alias will be removed only for the current session)

Some useful aliases that you can make:
$ ssh -p 2299 user_name@192.168.0.105	<- To connect to a server with SSH, instead of memorizing port and IP, use alias
$ alias ports='netstat -tupan'		<- List ports
$ alias root='sudo su -'		<- Alias for the command to become superuser
$ alias update='sudo apt update && sudo apt dist-upgrade -y && sudo apt clean'    <- Update the system
$ alias lt='ls -hSF --size -1'		<- List files in 1 column, sorted by size, in a human readable format



LESSON: SHELL
*************
Shell: A shell(command interpreter) is an interface between the user and the kernel.
Shell gets started when the user logs in and starts the terminal

Commands to check which shell is on your device:   $ echo $0		(or)		$ echo $SHELL
OUTPUT:
/bin/bash

Some other types of shells:
BOURNE, BASH, Z SHELL, C SHELL, KORN SHELL...
Bash is one of the most common shell on linux distributions

Command to see all shells:   $ cat /etc/shells
OUTPUT:
# /etc/shells: valid login shells
/bin/sh
/bin/bash
/usr/bin/bash
/bin/rbash


To change the default shell:   $ chsh -s <path_to_shell>
ex:  $ chsh -s /bin/bash

Different users can have different bash as default, and some have none(nologin)
To check the bash of all users: $ cat /etc/passwd


Shell Script: It is an executable text file that contains shell commands and other specific programming structures.
It is a powerful system administration tool.. Can be used to automate repetitive tasks.

Some common sysadmin tasks where shells/scripts can be used
1. Monitoring the system
2. Data backup and restoring
3. Creating an alert system
4. User administration
5. Security auditing
etc....


LESSON: CREATING A SCRIPT
**************************
Let's create a script which will do the following tasks:
Create a folder in current directory named 'dir1', create a new file inside that folder named 'file.txt' with the contents "Hello Bash World" inside it, display the directory tree of outermost folder, then display contents of file.txt

$ vim first_script.sh		<- Creating a shell script

=======SCRIPT=======
mkdir -p dir1
echo "Hello Bash World" > dir1/file.txt
tree .
cat dir1/file.txt
=====END SCRIPT=====
Save and exit vim: 	:wq

Give executable permissions to the script:  $ chmod +x first_script.sh

To execute: $ ./first_script.sh		<- Have to specify the directory of script

=======OUTPUT======
├── dir1
│   └── file.txt
├── first_script.sh
└── helloworld.sh

1 directory, 3 files
Hello Bash World
======END OUTPUT======


To be able to execute the script from any directory, modify the $PATH variable.. to do so:
Open the bashrc file from root directory:  $ vim ~/.bashrc
At the end of file, add the command:	   export PATH="$PATH:~/scripts"



LESSON: SHEBANG
****************
For executable scripts, the system expects 'shebang' in the first line...
Shebang is a character sequence: #!
This is followed by the path to interpreter...
For a bash script, it is #!/bin/bash
If shebang and path are not provided, the default interpreter is used... (bash in our first_script.sh case)

To check the path to shell:  $ which $SHELL
OUTPUT:  /bin/bash

We can add the following line to the top of our script:
#!/bin/bash


Let's understand use of shebang with a python code...
To find path to python3: which python3
OUTPUT: /usr/bin/python3

=======helloworld======== (Note: We didn't provide the .py extension)
#!/usr/bin/python3
print("Hello World")
========END============

Give executable permissions: $ chmod +x helloworld
To execute:  ./helloworld

OUTPUT:
Hello World

Therefore, using shebang we manually provide the interpreter to be used for that script.



LESSON: COMMENTS
*****************
In Bash, comments are started with a '#' sign
Bash ignores everything on a line after the '#' symbol.
The only exception is Shebang i.e #!

Comments helps a lot with code readability, maintainability..

Bash doesn't provide any direct method for multi-line comments. However, we can use the following trick:
: '		<-colon, space, inverted-comma  (This specifies the start of multi-line comment)
<some random words>
<this is commented out>
'		<-inverted-comma (Specifies the end of multi-line comment)
This trick isn't common, and usually multi-line comments are just a bunch of single-line comments


============comments.sh================
#!/bin/bash

echo "This script demonstrates comments"

#Im a single line comment. I wont be executed

echo "The single-line comment was skipped"

: '
Im a multi-line comment
Will I be executed? Find out for yourself
date; ls
'

echo "End of program"
============END comments.sh================

Give executable permissions: $ chmod +x comments.sh
Execute: $ ./comments.sh


===========OUTPUT===============
This script demonstrates comments
The single-line comment was skipped
End of program
=========END OUTPUT=============



LESSON: WAYS TO RUN SCRIPTS
****************************
1. Common:
 $ chmod +x script_name.sh
 $ ./script_name.sh
(Note: If script is not in current dir, you must mention absolute path of the script)

2. Mention the interpreter (In this method, setting execution permission isn't mandatory)
 $ bash bash_script.sh
 $ python3 python_script.py
This will also over-write the script shebang interpreter directive

3. Using source
 $ source bash_script.sh



LESSON: VARIABLES
*****************
A variable is a name for a memory location where a value is stored.
eg: PORT="32"
(Note: There should be no spaces before/after the '=' sign


Bash is weakly-typed i.e you don't need to assign the type while creating a variable.
No floats in Bash.

On CLI terminal:
$ fname="Sohail"
$ lname="Akthar"
$ fullname="$fname $lname"
$ echo $fullname

OUTPUT:
Sohail Akthar


Command to get a list of all the shell variables and functions:
$ set

To find our variable, we can pipe this command with 'grep' command
$ set | grep "fullname"

Command to undefine/remove the variable
$ unset "fullname"


To declare a constant variable ie variable whose value cannot be modified
$ declare -r NAME="SOHAIL"

$ echo $NAME
OUTPUT:
SOHAIL

$ NAME="AKTHAR"
OUTPUT:
bash: NAME: readonly variable


Variable Naming Conventions:
1. Shell variables use capital letters (eg: $PATH, $USER, $HOME, $HISTFILE, $HISTSIZE)
2. To distinguish with shell variables, use lower letters with underscores
3. Variable names should be descriptive
4. Cannot start with a number
5. Cannot contain spaces or other special characters
6. Can start with an underscore
7. Constants should be all capital




LESSON: VARIABLE ASSIGNING & EXPANSION
**************************************
Variable substitution/expansion:
The '$' character introduces parameter expansion, command substitution, or arithmetic expansion.
eg: echo $var_name
'$var_name' is a simplification of:  ${var_name}
Mentioning '{}' is mandatory if you're appending something to the variable

On CLI Terminal:
$ os="Windows"		<- Creating a variable 'os' with value=Windows
$ echo $os		<- Print value of the variable 'os'
Windows			<- OUTPUT
$ echo ${os}		<- Print value of the variable 'os'
Windows			<- OUTPUT
$ echo $os11		<- Print value of the variable 'os' along with '11' appended to it
			<- Empty OUTPUT (Because it tried to find the variable 'os11'
$ echo ${os}11		<- Print value of the variable 'os' along with '11' appended to it
Windows11		<- OUTPUT (Value of the variable 'os' along with '11' appended to it)



LESSON: QUOTING
****************
Quoting is used to remove the special meaning of certain characters or words.
To prevent reserved words from being recognized and prevent variable expansion.

Bash quoting mechanisms:
1. Single quotes =>  ''
2. Double quotes =>  ""
3. The escape character =>  \


Single Quotes
``````````````
eg:
$ echo 'will I print $NAME'
OUTPUT:
will I print $NAME	<- (Note: The variable 'NAME' was not dereferenced)

NOTE:
A single quote cannot occur between the single quotes.. even if we use '\'
$ 'I'm Sohail'	<- Doesn't execute
$ 'I\'m Sohail'	<- Doesn't execute



Double Quotes
`````````````
Preserves the value of all the characters within the quotes with the exception of $, ``, \\

On CLI Terminal:
$ echo "will I print $NAME"
OUTPUT:
will I print SOHAIL	<- (Note: The variable 'NAME' was dereferenced, unlike when single-quotes were used)

NOTE:
We can use "(double-quotes) if we precede it with the escape character '\'
$ "I"m Sohail"	<- Doesn't execute
$ "I\"m Sohail"
I"m Sohail	<- OUTPUT



BACKSLASH
``````````
Gives the literal value of following character.

On CLI Terminal:
$ echo "My name is $NAME"
My name is SOHAIL		<- OUTPUT ($NAME was dereferenced)
$ echo "My name is \$NAME"
My name is $NAME		<- OUTPUT ($NAME wasn't dereferenced, because it took literal value of '$')


On CLI Terminal:
$ echo me & you			   <- Trying to print 'me & you'
[ERROR] Command 'you' not found    <- Because '&' has special meaning ie run process in background
$ echo me \& you
me & you			   <- Using '\' to get literal value of '&'

$ echo 'me \& you'
me \& you
$ echo "me \& you"
me \& you

#To print '\' use '\\'
$ echo C:\Windows
C:Windows
$ echo C:\\Windows
C:\Windows



LESSON: ENVIRONMENT AND SHELL LOCAL VARIABLES
**********************************************
Each time we launch a terminal, a collection of predefined variables are set.
They are: Environment variables and Shell local variables

1. Environment variables:
inherited by any child shells or processes
used to pass info to processes that are spawned from the current shell
displayed using env or printenv

2. Shell variables:
are contained exclusively within the shell in which they were set
displayed using set


Environment variables can be useful to change default settings of PC. Env variables are also called exported variables.



LESSON: TAKING/PROMPTING INPUTS
*******************************
The 'read' command is used to take input from the user (Until a newline ie pressed 'Enter' key)

On CLI Terminal:
$ read name
Sohail		<- Input given
$ echo $name
Sohail		<- Output
#Multiple inputs can be taken and stored in variables like this:
$ read $age $city
20		<- Input provided by user
Hyderabad	<- Input provided by user
$ echo $age
20
$ echo $city
Hyderabad

If the variable isn't specified, the value will be stored in a predefined variable called 'REPLY'

$ read
Hello
$ echo $REPLY
Hello

To perform read along with some message for the user, use the '-p' 
$ read -p "your_message" variable_name

On CLI Terminal:
$ read -p "Enter your name: " name
Enter your name: Sohail
$ echo $name
Sohail

#Wrote a script which will read IP Address as input and blocks all packets from that address
#drop_packets_for_specific_ip.sh

To read any sensitive information, you don't want it to display while you're typing. So, use '-s' in 'read' command
$ read -s -p "Enter password: " mypass

$ echo $mypass
helloworld


LESSON: POSITIONAL PARAMETERS
******************************
Consider the following command:
$ apt install nginx
Here, 'apt' is the script name, 'install' is its first argument and 'nginx' is its second argument
The spaces between script name and parameters is called IFS(Internal Field Separator)

Parameters referenced by a name are called variables.
Parameters referenced by a number are called positional parameters
Parameters referenced by a special symbol are auto-set parameters

Positional Parameters:
Consider the following command
$ ./script.sh filename.txt directory1 10.0.0.1
Here,
$0 => the name of the script itself(script.h)
$1 => the first positional parameter(filename1)
$2 => the second positional parameter(directory1)
$3 => the third parameter of the script(10.0.0.1)
similarly, if we had more parameters, $4 would correspond to fourth argument and so on.
For more than one-digit, number must be enclosed in '{}'... eg: ${10} for tenth argument

Let's write a script.
=============positional_arguments.sh==============
#!/bin/bash
echo "0. Script name (\$0) is $0"
echo "1. The value of positional argument (\$1) is $1"
echo "2. The value of positional argument (\$2) is $2"
echo "3. The value of positional argument (\$3) is $3"
echo "4. The value of positional argument (\$4) is $4"
===============END SCRIPT===========================

$ chmod +x positional_arguments.sh
$ ./positional_arguments.sh
=================OUTPUT========================
0. Script name ($0) is ./positional_arguments.sh
1. The value of positional argument ($1) is 
2. The value of positional argument ($2) is 
3. The value of positional argument ($3) is 
4. The value of positional argument ($4) is 
================================================

(NOTE: Since we didn't pass any arguments when executing the script, no values are printed.

$ ./positional_arguments.sh arg1 arg2 arg3 arg4
=================OUTPUT========================
0. Script name ($0) is ./positional_arguments.sh
1. The value of positional argument ($1) is arg1
2. The value of positional argument ($2) is arg2
3. The value of positional argument ($3) is arg3
4. The value of positional argument ($4) is arg4
=================================================


Setting default parameter in case user doesn't provide any argument.
With the positional parameter, add ':-' followed by the default value... eg: ${1:-NULL}... NULL is the default 
Let's modify the previous script

===============positional_arguments.sh========================
#!/bin/bash
echo "0. Script name (\$0) is $0"
echo "1. The value of positional argument (\$1) is ${1:-MISSING_ARG_1}"
echo "2. The value of positional argument (\$2) is ${2:-MISSING_ARG_2}"
echo "3. The value of positional argument (\$3) is ${3:-MISSING_ARG_3}"
echo "4. The value of positional argument (\$4) is ${4:-MISSING_ARG_4}"
========================END SCRIPT=================================

$ ./positional_arguments
=====================OUTPUT===========================
0. Script name ($0) is ./positional_arguments.sh
1. The value of positional argument ($1) is MISSING_ARG_1
2. The value of positional argument ($2) is MISSING_ARG_2
3. The value of positional argument ($3) is MISSING_ARG_3
4. The value of positional argument ($4) is MISSING_ARG_4
=======================================================



Exercise: Create a script which takes filename as input, displays contents of the file and makes a compression
=================display_and_compress.sh================
#!/bin/bash
echo "Display contents of $1 ..."
sleep 2
cat "$1"
echo
echo "Compressing $1 ..."
sleep 2
tar -cjvf "$1.tar.gz" $1

echo "Done"
======================END SCRIPT==========================

$ chmod +x display_and_compress.sh
$ ./display_and_compress.sh file.txt
======================OUTPUT============================
Display contents of file.txt ...
987-123-4567
123 456 7890
(123) 456-7890

Compressing file.txt ...
file.txt
Done
==========================================================


Exercise: Create a script that will drop all packets coming from a specific ip/domain
=================exercise2.sh=======================
#!/bin/bash
read -p "Enter IP, Network or Domain to drop: " ip
echo "Blocking connections from $ip"
sleep 1
iptables -I INPUT -s $ip -j DROP
echo "Done"
====================END SCRIPT=======================


$ chmod +x exercise2.sh
$ sudo ./exercise2.sh		<- sudo because the command 'iptables' requires it
=====================OUTPUT==========================
Enter IP, Network or Domain to drop: 1.1.1.1
Blocking connections from 1.1.1.1
Done
=====================================================

You can check it by 'ping 1.1.1.1' in other terminal


A little variation to this script, instead of reading input from user, pass ip as an argument(This is better for automation)
==================exercise2_1.sh======================
#!/bin/bash
echo "Blocking connections from $1"
sleep 1
iptables -I INPUT -s $1 -j DROP
echo "Done"
===================END SCRIPT=========================

$ chmod +x exercise2_1.sh
$ sudo ./exercise2_1.sh 8.8.4.4
====================OUTPUT==========================
Blocking connections from 8.8.4.4
Done
====================================================




LESSON: SPECIAL PARAMETERS
***************************
Bash shell treats several parameters in some special way.
These parameteres can only be referenced and assigning to them is not allowed.

Some special parameters:
$0 => name of the script itself
$@ and $* => a string representation of all positional parameters
$# => number of positional arguments(in decimal)
$? => most recent foreground command exit status (Each command returns exit status... 0 is for success, 1 for error) 
$$ => process ID of the shell


===================special_parameters.sh=====================
#!/bin/bash
echo "\$0 is $0"
echo "\$@ is $@"
echo "\$* is $*"
echo "\$# is $#"
echo "\$? is $?"
echo "\$$ is $$"
==========================END SCRIPT===========================

$ chmod +x special_parameters.sh
$ ./special_parameters.sh a b c 1 2 3
========================OUTPUT========================
$0 is ./special_parameters.sh
$@ is a b c 1 2 3
$* is a b c 1 2 3
$# is 6
$? is 0
$$ is 16473
======================END OUTPUT======================


Let's take a look at '$?'  (It gives the exit status of most recent foreground command)
On CLI Terminal
$ echo hello
hello		<- Command executed succesfully

$ echo $?
0		<- Exit status 0 (Most recent foreground command was successfully executed)

$ cat x
cat: x: No such file or directory	<- Error

$ echo $?
1		<- Exit status 1 (Previous command didn't execute well)

$ lps
Command 'lps' not found

$ echo $?
127		<- Exit status 127 (for command not found error)



Difference between '$@' and '$*'
`````````````````````````````````
Both '$@' and '$*' expand to a string representation of all positional parameters($1 $2 $3 ...) but differ when they are wrapped inside double quotes.

$@   => word splitting is performed and $@="$1 $2 $3"
"$@" => word splitting is not performed and "$@"="$1" "$2" "$3"

$*   => is the same as unquoted $@
"$*" => will place the first character of the IFS variable between parameters


=============dollar_at.sh===============
#!/bin/bash
touch $@   # touch "$1 $2 $3"		<- create files mentioned in parameters
========================================

$ chmod +x dollar_at.sh
$ ./dollar_at.sh "my file.txt" "your report.txt"
$ ls
my	report.txt
your	file.txt
(Note: 4 differenet files were created, "my", "file.txt", "your", "report.txt")


Let's update $@ to "$@"
=============dollar_at.sh===============
#!/bin/bash
touch "$@"   # touch "$1" "$2" "$3"		<- create files mentioned in parameters
========================================

$ chmod +x dollar_at.sh
$ ./dollar_at.sh "my file.txt" "your report.txt"
$ ls
"my file.txt"	"your report.txt"
(Note: Only 2 files were created, ie word splitting was not performed)


$* is the same as $@
But, "$*" is different, let's make a script dollar_star.sh

===================dollar_star.sh======================
#!/bin/bash
IFS=:
touch "$*"
=====================END SCRIPT========================

$ chmod +x dollar_star.sh
$ ./dollar_star.sh "my file.pdf" "your report.pdf"
$ ls
'my file.pdf:your report.pdf'

(Note: "$*" treated positional parameters as one word, created a single file... The space between parameters was replaced by the IFS we set=':' (colon) in script



LESSON: SHELL EXPANSIONS
*************************
Command Line Processing:
1.Tokenization -> 2.Command Identification -> 3.Shell Expansions -> 4.Quote Removal -> 5.Redirections ->6. Execution

Different kinds of expansions and order in which they are performed.
1. Brace expansion
2. Tilde expansion
3. Parameter and variable expansion
4. Command substitution
5. Arithmetic expansion
6. Process substitution
7. Word splitting
8. Filename expansion(Globbing)



+++++++3. SHELL EXPANSIONS+++++++

1. Brace Expansion:
````````````````````
It is a mechanism by which arbitrary strings may be generated.
Types:  a) String lists
	b) Range (sequence) lists


a) String Lists:-
""""""""""""""""""
echo {old,new,current,backup}
old new current backup 
(Expression was expanded into list of strings)

Syntax: optional_prefix{value1,value2,value3}optional_suffix
Examples:
{a..k}			<- a b c d e f g h i j k
file{01..05}.txt	<- file01.txt file02.txt file03.txt file04.txt file05.txt
Day{1..7}		<- Day1 Day2 Day3 Day4 Day5 Day6 Day7

$ echo "Hello "{Sohail,Shoaib,Faizan}!
Hello Sohail!  Hello Shoaib!  Hello Faizan!

(NOTE: Should not add any spaces before/after the commas in braces)

$ echo {hey, there}
{hey, there}


Brace expansions can be nested:-
$ echo {old,new-{york,hafeezpet,testament},backup}
old new-york new-testament new-hafeezpet backup



b) Range(Sequence) Lists:-
""""""""""""""""""""""""""
Generates a sequence with given range(start, end)

$ echo {1..10}
1 2 3 4 5 6 7 8 9 10

$ echo {j..m}
j k l m

# It can fix width for digits by placing leading zeros:
$ echo {01..10}
01 02 03 04 05 06 07 08 09 10

# We can also specify jump/increment
$ echo {1..15..2}
1 3 5 7 9 11 13 15

$ echo {a..z..2}
a c e g i k m o q s u w y

# The range can be reversed
$ echo {10..2}
10 9 8 7 6 5 4 3 2

$ echo {z..a..3}
z w t q n k h e b

(Note: Both values(start,end) inside braces must be of same type...)
$ echo {z..1}  <- This is invalid


(Note: Brace expansion happens before variable expansion... Let's demonstrate)
$ a=2
$ echo {$a..10}
{2..10}

Here, expected output was: '2 3 4 5 6 7 8 9 10'
But, braces were expanded first hence it didn't expand the value of a to 2.



Exercise: Write command such that it does the following:
 i. Create three directories namely Jan, Feb, March
 ii. The three directories Jan,Feb,March must each have 31,28,31 directories inside of them respectively named 01,02,.....
 iii. The internal directories of all Jan,Feb,March must have a log file inside namely log.daily

Solution:
$ sudo mkdir -p ./app/{Jan/{01..31},Feb/{01..28},March/{01..31}}
$ sudo touch ./app/{Jan/{01..31},Feb/{01..28},March/{01..31}}/log.daily

Files are in: Bash/scripts/exercise3/



2. Tilde Expansion
```````````````````
It expands to home directories, current or previous working directory, directories from the directory stack.
Examples:
~     => $HOME of the current user
~USER => User's home directory
~+    => $PWD (Present Working Directory)
~-    => $OLDPWD (Old PWD)


$ echo ~
/home/sohail

$ echo ~+
/home/sohail/Learning/Bash/scripts		<- This is where I executed the above command from ie PWD(present working directory)

$ echo ~-
/home/sohail/Learning/Bash/scripts/exercise3	<- This is where I was before moving to PWD


$ echo root
/root		  <- home directory of user 'root'

$ echo sohail
/home/sohail	  <- home directory of user 'sohail'



3. Parameter Expansion
```````````````````````
'$' symbol introduces parameter expansion

Syntax:
$parameter
${parameter}

Examples:
echo $USER
echo ${HOME}


$ os=Linux
$ echo $os
Linux

# Use curly braces to append something to the variable
$ echo $osMint
			<- No output, because it searched for a variable named 'osMint'
$ echo ${os}Mint
LinuxMint		<- This works as expected


There are some expansion operators which modify the case of letters in the expanded variables
^^  <- Change to all caps
,,  <- Change to all smalls

$ echo ${os^^}
LINUX

$ echo ${os,,}
linux


Moving on to slightly advanced...
If we mistype variable name, or specify a variable which doesn't exist, IT may break the script.
ex: ping $ip		<- We didn't declare/assign any variable called ip
ping: usage error: Destination address required

In such cases we can make a check if a value for variable exists and eventually use the value or a default

Along with the variable name add ':-' and then the default value
$ ping ${ip:-1.1.1.1}		<- 1.1.1.1 is default if ip variable is not found
PING 1.1.1.1 (1.1.1.1) 56(84) bytes of data.	<- OUTPUT

If we try to echo the ip variable, we will not get any output.. Because we just substituted the default value and not actually assign it to the ip variable
$ echo $ip
		<- No output

We can however, replace :- with := to get the desired result ie assign default value to the variable if it is not found
$ ping ${ip:=1.1.1.1}
PING 1.1.1.1 (1.1.1.1) 56(84) bytes of data.	<- OUTPUT

$ echo $ip
1.1.1.1		<- We got the output



4. Command Substitution
````````````````````````
It means saving the output of a command in a variable

Syntax: `command` or $(command)		<- In first syntax, it is back-tick sign and NOT the single quote

Examples:
p="$(ping 8.8.8.8)"
users="`cut -d: -f1 /etc/passwd`"
echo $users


Let's assign the output of date command to a variable called dt
$ dt="$(date)"
$ echo $dt
Friday 14 July 2023 04:11:24 PM IST


Let's use another syntax. This time store output of whoami into variable called whothis
$ whothis="`whoami`"	<- Note that the sign is `(backtick) and not single quote
$ echo $whothis
sohail			<- Output (result of the command - $ whoami)


Exercise: Use command substitution ie store date in yyyy-mm-dd format in a variable. Use this variable to create a compressed file .tar.gz and name it with the value of variable
Ex: 2023-07-14.tar.gz

$ now="`date +%F`"			<- %F is a formatter to get date in yyyy-mm-dd format
$ tar -cvjf "${now}.tar.gz" file.txt	<- command to make a compressed file
$ ls
2023-07-14.tar.gz  file.txt		<- Successfully compressed file.txt with the name '2023-07-14.tar.gz'

Or simply,
$ tar -cvjf "$(date +%F).tar.gz" file.txt	<- Instead of storing in variable and then passing it, we're directly passing in the command
$ ls
2023-07-14.tar.gz  file.txt



5. Arithmetic Expansion
````````````````````````
It's used to perform mathematical computation

Syntax: $((expression))

Examples:
a=$((2**10))
b=$((10*5/2))

$ x=$((7*9))
$ echo $x
63

$ x=$((7**9))
$ echo $x
40353607

Precedence is same as any other language

Shell allows arithmetic expressions to be evaluated using let
$ let y=2**8
$ echo $y
256

$ let y=2**128	<- overflow
$ echo $y
0

Limitations:
Overflow, divideByZero, Arithmetic expressions can be done only using integers(cannot handle floats)
Use 'bc' command to perform float operations (bc: basic calculations) with pipe.. and scale
$ echo "11/4" | bc
2

$ echo "scale=2;11/4" | bc	<- scale=2 specifies the precision
2.75

bc can also be used like this:
$ bc <<< "scale=3;23/7"
3.285

<<< allows a string to be used as a standard input for a command

Note that bc also has interactive mode
$ bc
6*5
30
scale=2
55/8
6.87


6. Process Substitution
````````````````````````
It means to reference the output of a process as a file

Syntax: <(command)

Examples:
grep -w "root" <(cat /etc/passwd)


In Linux, everything is a file, so output of a process can internally be represented as a file too

$ echo <(ls)
/dev/fd/63

$ cat <(ls)
exercise3
file.txt


Let's use process substitution to compare two directories using the diff command
Firstly, create dir1 with a,b inside it
		dir2 with a,c inside it
$ diff <(ls dir1) <(ls dir2)
2c2
< b
---
> c



7. Word Splitting
``````````````````
All the results of previous stages, not occuring in double-quotes are subjected towards word splitting.
To perform word splitting, bash needs a delimited. For this it uses IFS which by default is space,tab,newline.
We can change delimiter by changing the IFS variable 

$ echo ${IFS@Q}
$' \t\n'	<- OUTPUT


$ dirs="dir1 dir2 dir3"
$ mkdir $dirs		<- We didn't wrap $dirs with double quotes, so word splitting will be done
$ ls
dir1  dir2  dir3	<- Word splitting was done and three separate directories are created

$ rm -rf dir1 dir2 dir3

$ mkdir "$dirs"
$ ls
'dir1 dir2 dir3'	<- It is a single directory named 'dir1 dir2 dir3'


Now, let's change IFS and try
$ dirs="dir 1:dir 2: dir 3"
$ IFS=":"			<- delimiter is ':'  so the words will be splitted at ':'
$ mkdir $dir
$ ls
'dir 1'  'dir 2'  'dir 3'



8. Filename Expansion(Globbing)
````````````````````````````````
There are 3 characters that perform Globbing:
   *   => matches any string, including emptiness (most commonly used)
   ?   => matches any single character
   []  => matches a single character from within a range

Unquotted globbing characters are considered patterns and replaced with a list of filenames matching the pattern.


Aestrisk(*)
""""""""""""
$ touch f{a..b}{1..3}.txt f
$ ls f*
f  fa1.txt  fa2.txt  fa3.txt  fb1.txt  fb2.txt  fb3.txt

(Note: we used ls f*  so, * matched emptiness too and we got 'f' in result as well)

$ echo fa*.txt
fa1.txt  fa2.txt  fa3.txt

(Note: * works only because it is unquoted)

$ echo "fa*.txt"
fa*.txt

$ ls "fa*.txt"
ls: cannot access 'fa*.txt': No such file or directory


Filenames starting with .(dot) ie hidden files are not matched by aestrisk(*)
$ touch .abc
$ ls *
f  fa1.txt  fa2.txt  fa3.txt  fb1.txt  fb2.txt  fb3.txt		<- .abc wasn't displayed


So, .a must be matched explicitly
$ ls .a*	
.abc


Question Mark(?)
""""""""""""""""
It marks any single character

$ ls fa?.txt
fa1.txt  fa2.txt  fa3.txt

If we had a file 'fa10.txt' it would've been ignored, because after 'fa' it has 2 characters.. but ? matches only single character
For that, we could specify two question marks(But previous files would be ignored)

$ ls fa??.txt
fa10.txt


Square brackets([])
""""""""""""""""""""
Used to match single character from within a range

$ ls fa[123].txt
fa1.txt  fa2.txt  fa3.txt

$ ls f[ab]*.txt
fa1.txt  fa2.txt  fa3.txt  fa10.txt  fb1.txt  fb2.txt  fb3.txt


# We can use ranges in square brackets as follows:
$ ls f[a-b][1-2].txt
fa1.txt  fa2.txt  fb1.txt  fb2.txt


[0-5a-dX-Z]  this is interpreted as  [012345abcdXYZ]


Negating pattern expression:
Using ! or ^

$ ls f[a]*	<- f followed by a and then any character
fa1.txt fa2.txt fa3.txt fa10.txt

$ ls f[^a]*	<- f followed by (NOT a) and then any character ... ie f shouldn't be followed by an 'a'
fb1.txt  fb2.txt  fb3.txt


So far, we have been using only 'ls' command but these(expansions) can be used with any other commands too
Let's remove all the fa1.txt fa2.txt etc
$ rm f[ab][1-3].txt 

(When using potentially dangerous commands like rm like this, it's always better to first echo which files will be affected)



++++++1. TOKENIZATION++++++
Bash uses metacharacters to break the command line into tokens(words and operators)

Metacharacters:  space,  tab,  newline,  |   ;   &   ()   <>

Token types:
1. Words(don't contain any unquoted metacharacters)
2. Operators(contain at least one unquoted metacharacter)


Opertaor types: (Operators only matter if they are unquoted)
1. Control(performs a control function):       newline    |    ||   &    &&    ;    ;;    ;&    ;;&    |&    ()
2. Redirection(redirect data stream like ip/op to file):  >    >>    >|    <>    >&    &>    <   <<    <<<    <&    <<-


Alias expansion is done at this step too



Consider the following command:
$ ls $HOME > home.txt	(list files/dirs from $HOME and add the output to home.txt)

First, tokenization happens which will tokenize the command into words and operators
words: ls, $HOME, home.txt
operators:  >  and the newline character at end of command
(note: $ is not a metacharacter)



++++++++COMMAND IDENTIFICATION++++++++++++
After tokenization, the shell will parse and identify the tokens into simple and compund commands.
1.Simple command: A sequence of words separated by blanks and terminated by either a new line or one of the shell's control operaors.
$ touch   a.txt   b.txt   c.txt   ls

Here, we might expect to create 3 files a.txt,b.txt,c.txt and then list files. But, the ouput is:
$ ls
a.txt   b.txt    c.txt   ls

A file names 'ls' was created.. ie shell didn't recognize ls as command, rather argument to touch

We can write two commands in one by separating them with a control operator. Like this:
$ touch a.txt b.txt c.txt; ls	(Notice the ';' before ls)
a.txt  b.txt  c.txt



2.Compound command: A command that starts and ends with a bash reserved word
(Reserved words are words that have special meaning to the shell. It includes words like if,then,elif,else,fi,etc)

You can check if a word is shell keyword by the following command:
Syntax:   $ type keyword

Example:
$ type if
if is a shell keyword		<- OUTPUT

$ type elif
elif is a shell keyword		<- OUTPUT




+++++++++SHELL EXPANSIONS++++++++++++
We've already seen expansions.



+++++++++QUOTE REMOVAL++++++++++++++++
All unquoted occurrences of backslashes(\), single quotes('') and double quotes("") that DID NOT result from an expansions are removed.

Ex:
$ echo $USER
student

$ echo \$USER
$USER

$ echo '"Linux"'
"Linux"

$ dir="C:\Windows\System"
$ echo $dir
C:\Windows\System


++++++++++++REDIRECTIONS++++++++++++
Every shell command has three data streams connected to it.
They are denoted by numbers:
STDIN(0)  => Standard Input	(<)
STDOUT(1) => Standard Output	(>, >>)
STDERR(2) => Standard Error	(2>, 2>>)


Standard Input:-
$ tail < /etc/group
Here, tail is getting std input from a file instead of keyboard


Standard Output:-
Normally, the output is printed on screen, but if we wish to save the output to a file, we can use stdout (>,>>)
$ ls > list.txt
Here, the output of 'ls' command will be saved in list.txt

$ cat list.txt
a.txt b.txt		<- contents of list.txt

Instead of overwriting, if we wish to append the output to a file, use '>>'
$ date >> list.txt

$ cat list.txt
a.txt b.txt
Sunday 16 July 2023 12:27:27 PM IST


Everything is linux is a file, or treated as one. Even terminal
To see the file which represents terminal, use the command:
$ tty
/dev/pts/1	<- OUTPUT

Now, open a new terminal and execute this command
$ date > /dev/pts/1

We'll see the output of date command in the previous terminal(ie /dev/pts/1)
(Pretty cool, isn't it?)



Standard Error:-
For this, let's consider a command which will return an error
$ tail /etc/shadow   (An unpriviledged user cannot access this file)
tail: cannot open '/etc/shadow' for reading: Permission denied

$ tail /etc/shadow 2> error.txt		(Note: space between 2 and > is not allowed)
$ cat error.txt
tail: cannot open '/etc/shadow' for reading: Permission denied


2> will create file if doesn't already exist, otherwise it'll overwrite the file.
To append to an existing file, use 2>>

$ tail /etc/shadow 2>> error.txt
$ cat error.txt
tail: cannot open '/etc/shadow' for reading: Permission denied
tail: cannot open '/etc/shadow' for reading: Permission denied

It is possible to redirect both output and error if a command results in both
$ tail -n 2 /etc/passwd /etc/shadow > output.txt 2> errors.txt


To redirect both outputs and errors to same file:
$ tail -n 2 /etc/passwd /etc/shadow > output_errors.txt 2>&1  (&1 represents the stream, without & it would've redirected it to file called 1)


Till now, we see that if we redirect output to a file, it won't display on screen
To get output in screen as well as redirect it to a file, use 'tee'


Command to get mac address:
$ ifconfig | grep ether
ether b8:ac:6f:dc:7a:4f  txqueuelen 1000  (Ethernet)

If we want to both, display on screen and also save in file:
$ ifconfig | grep ether | tee mac.txt
ether b8:ac:6f:dc:7a:4f  txqueuelen 1000  (Ethernet)

$ cat mac.txt
ether b8:ac:6f:dc:7a:4f  txqueuelen 1000  (Ethernet)


tee overwrites a file... To append, use -a
$ who | tee -a mac.txt
sohail   tty2         2023-07-16 09:15 (tty2)

$ cat mac.txt
        ether b8:ac:6f:dc:7a:4f  txqueuelen 1000  (Ethernet)
sohail   tty2         2023-07-16 09:15 (tty2)




+++++++++COMMAND EXECUTION++++++++++++
After all the previous steps, the command will be executed.



Brief overview of Command Line Processing with an example:
Consider the following command
$ ls $HOME > $(date +%H_%M).txt


Step-1: Tokenization
`````````````````````
The command will be tokenized into words and operators

words: (total 3)
1. ls
2. $HOME
3. $(date +%H_%M).txt     (Note: space inside $(date +%H_%M) is not considered because it is quoted)

(Note: $ is not a metacharacter... therefore $HOME and $(date +%H_%M) are considered words

operators:
1. space
2. >
3. newline



Step-2: Command Identification
```````````````````````````````
Here, the command is identified as simple or compound.
In our case, the command didn't start/end with reserved word, so it is a simple command.
The entire command is is terminated by a single newline at the end, so it is a single simple command
(Note: > sign is not control operator, rather redirection operator)


Step-3: Shell Expansion
````````````````````````
In our example, there are two types of expansions
$HOME : variable expansion
$(date +%H_%M).txt : Command substitution

So, after shell expansion, our command will be:
$ echo $HOME
/home/sohail

$ echo $(date +%H_%M)
13_12				<- OUTPUT  (13 represents Hours, 12 represents Minutes)


Therefore, resultant command will be:
$ ls /home/sohail > 13_12.txt


Note: Word splitting is not done because /home/sohail and 13_12 do not have spaces(default IFS)
Note: Globbing is not done because there is not unquoted (aestrisk)* (question-mark)? or (square-brackets)[]



Step-4 Quote Removal
````````````````````
In our example, there are no unquoted backslashes(\) or single-quotes('') or double-quotes("")
So, we move to next step.



Step-5 Redirection
```````````````````
We have one redirection operator in our example (>)
So shell knows that it has to redirect output of 'ls /home/sohail' (left side of >) to '13_12.txt' (right side of >)



Step-6 Command Execution
`````````````````````````
After completing all the prior steps, the command is executed.




LESSON: PROGRAM FLOW CONTROL
*****************************
In this lesson:
  -> Conditional Statements
  -> Logical Operators
  -> Nested Blocks
  -> Arithmetic Comparisons
  -> String Comparisons
  -> Case Statements



If, Elif and Else Statements:
``````````````````````````````
Syntax:- (Note: It is a compound statement, as it starts and ends with reserved keyword)

if [ some_condition_is_true ]
then
    #1.execute_this_code
elif [ some_other_condition_is_true ]
then
    #2.execute_this_code
else
    #3.execute_this_code
fi


Note: The space before and after if,elif are necessary


Let's write a script.
We will run the script with an argument(filename).. script should check if the file exists and is a regular file(ie not a directory) and print the contents of it


================if1.sh===================
#!/bin/bash
if [ -f "$1" ]
then
    echo "The argument ($1) is a file, displaying its contents..."
    sleep 1
    cat $1
elif [ -d "$1" ]
then
    echo "The argument ($1) is a directory."
else
    echo "The argument ($1) is neither a file nor a directory."
fi
=============END SCRIPT==================

Note: Use '$ man test' to check all the tests you can use to check condition

$ chmod +x if1.sh
$ ./if1.sh exercise3  	<- exercise3 is a folder
The argument (exercise3) is a directory

$ ./if1.sh helloworld.sh
The argument (helloworld.sh) is a file, displaying its contents...
#!/bin/bash
print("Hello World")

We got the contents of helloworld.sh as output.


$ ./if1.sh some_random_nonexisting_name
The argument (some_random_nonexisting_name) is neither a file nor a directory.


Normally we would've got an error if we perform cat on directory or non-existing file



In our script, we used double-quotes with the argument ie "$1"... This is to prevent word splitting.
But there's another way to do this, using double square-brackets instead of one
if [ -f "$1" ]    ==>   if [[ -f $1 ]]
The double square-brackets also have the feature of regular expression matching.



Integer Comparison
```````````````````
Use '$ man test' to get a complete list of allowed conditional testing.
It includes the following for integers:-
INTEGER1 -ge INTEGER2
     Return true if INTEGER1 is greater than or equal to INTEGER2
Similarly,
-gt  : for greater than
-eq  : for equal to
-ne  : not equal to
-lt  : for less than
-le  : for less than or equal to


Exercise: Write a script that'll read input from user and print following for respective input:
input<18  : "You are minor!"
input==18 : "Congratulations! You've just become major"
input>18  : "You are major!"

================checkAge.sh==================
#!/bin/bash
read -p "Enter your age: " age
if [[ $age -lt 18 ]]
then
	echo "You are minor!"
elif [[ $age -eq 18 ]]
then
	echo "Congratulations! You've just become major"
else
	echo "You are major!"
fi
===============END SCRIPT===================

$ chmod +x checkAge.sh

$ ./checkAge.sh
Enter your age: 18
Congratulations! You've just become major

$ ./checkAge.sh
Enter your age: 12
You are minor!

$ ./checkAge.sh
Enter your age: 23
You are major!




Multiple Conditions and Nested If
``````````````````````````````````
In our previous script checkAge.sh if we give negative input, it'll print "You are minor!" but logically, age cannot be negative
Similarly, age can't be absurdly high like 200..
We can solve this by using multiple conditions using logical operators

After updating the script:-
===================checkAge.sh====================
#!/bin/bash
read -p "Enter your age: " age
if [[ $age -lt 18 && $age -ge 0 ]]
then
	echo "You are minor!"
elif [[ $age -eq 18 ]]
then
	echo "Congratulations! You've just become major"
elif [[ $age -gt 18 && $age -lt 100 ]]
then
	echo "You are major!"
else
	echo "Invalid age!"
fi
=================END SCRIPT==========================

$ ./checkAge.sh
Enter your age: -1
Invalid age!

$ ./checkAge.sh
Enter your age: 150
Invalid age!


NOTE:
Logical Operators:
1. Logical AND =>   && for [[ test ]]     and      -a for [ test ]
2. Logical OR  =>   || for [[ test ]]     and      -o for [ test ]



Let's rewrite the above program, here we'll pass age as argument while executing the script..
If argument age is not present display "Please provide an argument" otherwise work normally as previous script.

===================checkAge2.sh=========================
#!/bin/bash
if [[ $# -gt 0 ]]
then
	if [[ $1 -lt 18 && $1 -ge 0 ]]
	then
		echo "You are minor!"
	elif [[ $1 -eq 18 ]]
	then
		echo "Congratulations! You've just become major"
	elif [[ $1 -gt 18 && $1 -lt 100 ]]
	then
		echo "You are major!"
	else
		echo "Invalid age!"
	fi
else
	echo "Please provide an argument"
fi
======================END SCRIPT==========================

$ ./checkAge2.sh
Please provide an argument

$ ./checkAge2.sh -3
Invalid age!

$ ./checkAge2.sh 8
You are a minor!



String Comparisons
```````````````````
Check if strings are NOT equal => !=
Check if strings are equal  =>    = for []    and    == for [[]]
String length is non-zero   =>    -n
String length is zero	    =>	  -z

Exercise: Write a script to check if the two strings provided by user are equal or not. Implement both single-brackets and double-brackets
=================compare_strings.sh======================
#!/bin/bash
read -p "String1: " str1
read -p "String2: " str2

echo
echo "Using single-brackets with if:-"

if [ "$str1" = "$str2" ]
then
	echo "String1 equals String2"
else
	echo "String1 does not equal String2"
fi

echo "-------------------------"
echo "Using double-brackets with if:-"

if [[ $str1 == $str2 ]]
then
	echo "String1 equals String2"
else
	echo "String1 does not equal String2"
fi
==================END SCRIPT=============================


$ ./compare_strings.sh
String1: Sohail Akthar
String2: Sohail Akthar

Using single-brackets with if:-
String1 equals String2
-------------------------
Using double-brackets with if:-
String1 equals String2


$ ./compare_strings.sh
String1: hey
String2: hello

Using single-brackets with if:-
String1 does not equal String2
-------------------------
Using double-brackets with if:-
String1 does not equal String2



Exercise: Write a script to check if a certain word is substring of a statement.
==================contains_substring.sh=====================
#!/bin/bash
statement="the big brown fox jumped over the lazy dog"
echo "The statement is: $statement"

if [[ $# -gt 0 ]]
then
	if [[ $statement == *$1* ]]
	then
		echo "true. $1 is a substring of this statement."
	else
		echo "false. $1 is NOT a substring of this statement."
	fi
else
	echo "Please provide an argument"
fi
======================END====================================

$ ./contains_substring.sh
The statement is: the big brown fox jumped over the lazy dog
Please provide an argument

$ ./contains_substring.sh dog
The statement is: the big brown fox jumped over the lazy dog
true. dog is a substring of this statement.

$ ./contains_substring.sh dogg
The statement is: the big brown fox jumped over the lazy dog
false. dogg is NOT a substring of this statement.



Exercise: Write a script to check if a string is zero length or not
============================string_length.sh===========================
#!/bin/bash
read -p "Enter a string: " str

if [[ -z $str ]]
then
	echo "String is zero length"
else
	echo "String is NOT zero length"
fi


if [[ -n $str ]]
then
	echo "String is NOT zero length"
else
	echo "String is zero length"
fi
=============================END SCRIPT================================

$ ./string_length.sh 
Enter a string: 
String is zero length
String is zero length

$ ./string_length.sh 
Enter a string: sohail
String is NOT zero length
String is NOT zero length



Exercise: Write a script that takes an ip as argument. Print whether there's connection to that ip or not.
===================test_connection.sh=====================
#!/bin/bash
output=$(ping -c 3 $1)

if [[ $output == *"100% packet loss"* ]]
then
	echo "The network connection to $1 is not working"
else
	echo "The network connectin to $1 is working"
fi
======================END SCRIPT===========================

$ ./test_connection.sh 1.1.1.1
The network connectin to 1.1.1.1 is working

$ ./test_connection.sh 1.1.2.3
The network connection to 1.1.2.3 is not working



LESSON: CASE STATEMENT(SWITCH)
```````````````````````````````
The case construct allows us to test strings and numbers and is an elegant way to implement logic in our scripts

Syntax:-
case "$variable" in			<- start of case
pattern1)
	execute_this_code_1
	;;				<- similar to break
pattern2)
	execute_this_code_2
	;;
patternN)
	execute_this_code_N
	;;
*)					<- default case
	execute_this_default_code	<- run if no pattern matches
	;;
esac					<- end of case



A script that takes input from user, and prints appropriate line:
====================favorite_pet.sh========================
#!/bin/bash
read -p "Enter your favorite pet: " pet

case $pet in
"dog")
	echo "Your fav pet is dog."
	;;
cat | Cat | kitty)
	echo "You like cats."
	;;
fish | "African turtle")
	echo "Fish or turtles are great!"
	;;
*)
	echo "Your favorite pet is unknown"
esac
======================END SCRIPT===========================

$ ./favorite_pet.sh 
Enter your favorite pet: dog
Your fav pet is dog.

$ ./favorite_pet.sh 
Enter your favorite pet: African turtle
Fish or turtles are great!

$ ./favorite_pet.sh 
Enter your favorite pet: horse
Your favorite pet is unknown


Exercise: Write a script that takes 2 arguments(signal number and process id). send appropriate signal to the process.
Note: To see all the signals you can send, use '$ kill -l' command
=======================signal.sh=========================
#!/bin/bash
if [[ $# -ne 2 ]]
then
	echo "Please provide two arguments: SignalNumber and ProcessID"
	exit 1
fi

case $1 in
1)
	echo "Sending SIGHUP signal to PID-$2"
	kill -SIGHUP $2
	;;
2)
	echo "Sending SIGINT signal to PID-$2"
	kill -SIGINT $2
	;;
15)
	echo "Sending SIGTERM signal to PID-$2"
	kill -SIGTERM $2
	;;
*)
	echo "Cannot send this signal"
esac
======================END SCRIPT=========================


Open a new terminal(T2) and type the following command to make it 'run in background'
$ sleep 100 &
[1] 15738		<- Here, 15738 is PID

In Terminal(T1):
$ ./signal.sh 1 15738
Sending SIGHUP signal to PID-15738

In Terminal(T2):
[1]   Hangup                  sleep 100


Similarly, for other signals(2,15):
[3]   Interrupt               sleep 100

[5]   Terminated              sleep 100



LESSON: BASH MENUS (SELECT)
```````````````````````````
The 'select' statement provides us with a dropdown menu to select from

Syntax:-
PS3="Select an option: "		<- PS3 is a prompt. By default it is set to '#?'

select ITEM in LIST_OF_OPTIONS
do
	COMMANDS
done


Here, ITEM is a user defined variable and LIST_OF_OPTIONS is a series of strings/numbers  

The select statement keeps executing until it reaches a break or user presses ctrl+c

A sample script using 'select':-
======================select.sh=======================
#!/bin/bash
PS3="Enter your choice: "

select COUNTRY in India Pakistan Bangladesh "United States"
do
	echo "Your country is $COUNTRY"
	echo "REPLY is $REPLY"
done
====================END SCRIPT========================

$ ./select.sh 
1) India
2) Pakistan
3) Bangladesh
4) United States
Enter your choice: 1
Your country is India
REPLY is 1
Enter your choice: ^C


Normally, select statement is used along with if/else or case.
=======================menu.sh=============================
#!/bin/bash
PS3="Enter your choice: "

select COUNTRY in India Bangladesh Pakistan "United States" Quit
do
	case $REPLY in
	1)
		echo "You probably speak Hindi"
		;;
	2)
		echo "You speak Bangla"
		;;
	3)
		echo "You speak Urdu"
		;;
	4)
		echo "You speak American English"
		;;
	5)
		echo "Qutting..."
		sleep 1
		exit
		;;
	*)
		echo "Invalid choice"
		;;
	esac
done
======================END SCRIPT==============================

$ ./menu.sh 
1) India
2) Bangladesh
3) Pakistan
4) United States
5) Quit
Enter your choice: 1
You probably speak Hindi
Enter your choice: 2
You speak Bangla
Enter your choice: 3
You speak Urdu
Enter your choice: 4
You speak American English
Enter your choice: 5
Qutting...



Exercise: Create a script with menu to perform following sysadmin tasks:
add user, remove user, list all processes, kill a process, install an app, remove an app, quit

========================system_administration.sh===========================
#!/bin/bash
PS3="Enter your choice: "
IFS=':'
OPTIONS="Add user":"Remove user":"List all processes":"Kill process":"Install program":"Remove program":"Quit"

select OPTION in $OPTIONS
do
	case $REPLY in
	1)
		read -p "Enter username: " username
		output="$(grep -w $username /etc/passwd)"
		if [[ -n $output ]]
		then
			echo "Username already exists!"
		else
			echo "Adding user..."
			sudo useradd $username
			if [[ $? -ne 0 ]]
			then
				echo "Adding user failed."
			else
				echo "User added successfully."
			fi
		fi
		;;
	2)
		read -p "Enter username: " username
		output="$(grep -w $username /etc/passwd)"
		if [[ -n $output ]]
		then
			echo "Removing user..."
			sudo userdel $username
			if [[ $? -ne 0 ]]
			then
				echo "Remove user failed."
			else
				echo "Removed user successfully."
			fi
		else
			echo "User doesn't exist."
		fi
		;;
	3)
		ps -aux
		;;
	4)
		read -p "Enter process id: " pid
		if [[ -n $pid ]]
		then
			echo "Killing the process with pid-$pid"
			kill -9 $pid
			if [[ $? -ne 0 ]]
			then
				echo "Killing process unsuccessful."
			else
				echo "Killed process successfully."
			fi
		else
			echo "Please enter a valid PID"
		fi
		;;
	5)
		read -p "Enter app name: " appname
		if [[ -n $appname ]]
		then
			echo "Installing app...."
			sudo apt install $appname
			if [[ $? -ne 0 ]]
			then
				echo "Install failed."
			else
				echo "Installed successfully."
			fi
		else
			echo "Please enter a valid app name"
		fi
		;;
	6)
		read -p "Enter app name to remove: " appname
		output="$(apt list 2> /dev/null | grep $appname)"
		if [[ -n output ]]
		then
			echo "Removing app..."
			sudo apt remove $appname
			if [[ $? -ne 0 ]]
			then
				echo "Remove failed."
			else
				echo "Successfully removed."
			fi
		else
			echo "App not found"
		fi
		;;
	7)
		echo "Qutting..."
		sleep 1
		exit
		;;
	*)
		echo "Invalid input"
		;;
	esac
done
=============================END SCRIPT=================================


$ ./system_administration.sh 
1) Add user	       3) List all processes  5) Install program     7) Quit
2) Remove user	       4) Kill process	      6) Remove program
Enter your choice: 1
Enter username: akthar
Adding user...
[sudo] password for sohail: 
User added successfully.

Enter your choice: 2
Enter username: akthar
Removing user...
Removed user successfully.

Enter your choice: 4
Enter process id: 24419
Killing the process with pid-24419
Killed process successfully.

Enter your choice: 7
Qutting...




LESSON: CHAINING COMMANDS
**************************
List operators:   ;   &    &&    ||

Till now, we were executing commands sequentially but using list operators it is possible to execute multiple commands
List is a sequence of one or more commands written on same line and separated by one of the list operators


1.Semi-colon(;)
```````````````
Using semicolon we can write multiple commands in single line.
Execution will be done sequentially. Shell waits for each command to execute and terminate.
Return status is the exit status of last command executed.
Note that there is no particular connection between the commands
This method is useful when you don't want to wait for the previous command to terminate.

Syntax:  command1; command2; command3

Example:
$ date; tail -n 1 menu.sh; echo [p..z]
Sunday 16 July 2023 10:06:55 PM IST
done
[p..z]



2.Ampersand(&)
``````````````
If a command ends with a '&', shell executes it asynchronously in a subshell aka execute in the background.
These are hence referred to as asynchronous commands.

Syntax:    command1& command2

Example:
$ sleep 10& date
[1] 25206
Sunday 16 July 2023 10:10:36 PM IST

Here, the date command didn't wait for sleep to terminate but was executed right away.



3.Double Ampersand(&&)
``````````````````````
Syntax:   command1 && command2

Here, && is logical and
Hence, command2 will execute if and only if previous command(1) return exit status 0(ie successful execution)

Example:
$ date && echo success
Sunday 16 July 2023 10:14:19 PM IST
success


$ ls /root && echo success
ls: cannot open directory '/root': Permission denied

Here, as the first command resulted in error, the second command didn't execute



4.Double Pipe(||)
``````````````````
Syntax:    command1 || command2

This is kinda opposite of &&
command2 will execute if and only if previous command(1) return a non-zero exit status(ie unsuccessful execution)

Example:
$ date || echo failure
Sunday 16 July 2023 10:19:00 PM IST

$ ls /root || echo failure
ls: cannot open directory '/root': Permission denied
failure


This is useful to process a possible error


&& and || can be used in combination like this:
command1 && command2 || command3
If command1 is success, execute command2 otherwise execute command3
This is like ternary operator



LESSON: DENIAL OF SERVICE ATTACK (FORK BOMB/RABBIT VIRUS/WABBIT) 
````````````````````````````````````````````````````````````````
It is a denial-of-service attack wherein a process continually replicates itself to deplete available system resources, slowing down or crashing the system due to resource starvation.

It can be executed by unpriviledged user and bring down the entire linux system.
Works on many linux distributions.

Test it on virtual machine and be prepared for a crash/forced reboot

================bomb.sh================
$0 && $0 &
==============END SCRIPT===============

Executing this script will cause resource starvation and crash the system.
Only way to recover is to force reboot.


Explanation of script:
$0 represents the script itself
So, the script is calling itself recursively two times and going in background and same goes on with called scripts


How to prevent such bombs?
Edit the limits.conf file:
$ sudo nano /etc/security/limits.conf

At the end of file, append the following line:
user_name	hard	nproc	2000

This will limit the user processes to 2000. Do not set it too low or you'll limit the user from using the system.

For a group, following line:
@group_name	hard	nproc	4000





LESSON: LOOPS
`````````````
A loop is a block of code that iterates a list of commands as long as the loop control condition is true.


For Loops:-
''''''''''''
Syntax:
for ITEM in LIST_OF_VALUES
do
	#Run_these_commands
done


Sample program to get familiar with for loop:
================================================
#!/bin/bash
for os in Ubuntu Kali Pop
do
	echo "os is $os"
done
================================================

os is Ubuntu
os is Kali
os is Pop


Here's a simple program to print the multiplication table of a user provided number n
=====================for_loop.sh=======================
#!/bin/bash
read -p "Enter n: " num
for i in {1..10}
do
	echo $num x $i = $(echo $num*$i | bc)
done
echo
====================END SCRIPT=========================

$ ./for_loop.sh 
Enter n: 10
10 x 1 = 10
10 x 2 = 20
10 x 3 = 30
10 x 4 = 40
10 x 5 = 50
10 x 6 = 60
10 x 7 = 70
10 x 8 = 80
10 x 9 = 90
10 x 10 = 100


For loop in bash is similar to the one in python but differs from the one in java/c++



Exercise: Create a script to display contents of all files in current directory
====================display_file_contents.sh==================
#!/bin/bash
for item in ./*	
do
	if [[ -f $item ]]	#Check if regular file
	then
		echo "Displaying contents of $item"
		sleep 1
		cat $item
		echo "#################################"
	fi
done
=====================END SCRIPT================================



Bash also has a Java/C styled for loop:-
===================cat java_styled_for_loop.sh ====================
#!/bin/bash
for (( i=0; i<=5; i++ ))
do
	echo "i=$i"
done
========================END SCRIPT==============================

$ ./java_styled_for_loop.sh 
i=0
i=1
i=2
i=3
i=4
i=5



Exercise: A txt file contains list of malicious ip address. Write a script to block packets from the listed ip addresses
$ cat malicious_ips.txt 
1.1.1.1
8.8.4.4


==================block_ips.sh =====================
#!/bin/bash
for ip in $(cat malicious_ips.txt)
do
	echo "Dropping packets from $ip"
	iptables -I INPUT -s $ip -j DROP
done
===================END SCRIPT=======================

$ sudo ./block_ips.sh 
[sudo] password for sohail:
Dropping packets from 1.1.1.1
Dropping packets from 8.8.4.4



While loops:-
'''''''''''''
The while loop is used to execute a series of commands as long as a specific condition is true.

Syntax:
while CONDITION
do
	#RUN_THESE_COMMANDS
done


Use While loop when number of interations is unknown.


A simple program using while loop:-
==============while_loop.sh =================
#!/bin/bash
i=0
while [[ $i -le 5 ]]
do
	echo "i is $i"
	(( i++ ))
done
==============END SCRIPT=====================

$ ./while_loop.sh 
i is 0
i is 1
i is 2
i is 3
i is 4
i is 5



An infinite while loop:-
================infinite_while_loop.sh================
#!/bin/bash
while :
do
	echo "Infinite loop. Press Ctrl+C"
done
==================END SCRIPT==========================


Notice the colon(:) after 'while' keyword. It is a bash built-in that always returns true.
We can also use the 'true' keyword like this ->  while true
We can also use any command in place of CONDITION. commands return exit status(0 for success/true and non-zero for failure/false)



While loop with input redirection:
===================while_read.sh====================
#!/bin/bash

while read line
do
	echo $line
done< /etc/passwd
====================END SCRIPT======================

Here, we're redirecting the contents of /etc/passwd to the while loop compound statement


While loop with process substitution:
Firstly, to get process as file:
$ <(ls)
bash: /dev/fd/63: Permission denied

=========while_read_process_substitution.sh =========
#!/bin/bash

while read line
do
	echo $line
done< <(ls)
===================END SCRIPT=========================



Exercise: Write the block_ips.sh script but using while loop instead of for
==================block_ips_using_while.sh=================
#!/bin/bash
while read line
do
	echo "Dropping packets from $line"
	iptables -I INPUT -s $line -j DROP
done< ./malicious_ips.txt
=====================END SCRIPT=============================

$ sudo ./block_ips_using_while.sh 
Dropping packets from 1.1.1.1
Dropping packets from 8.8.4.4



LESSON: BREAK AND CONTINUE
``````````````````````````
The break and continue statements allow you to control the loop execution.

With break you can exit from a for,while,until,or select loop
The continue statement skips the remaining commands inside the loop for the current iteration and passes program control to the next iteration of the loop


DONE TILL LESSON 52
